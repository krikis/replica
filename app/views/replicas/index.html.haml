
:coffeescript
  $ ->
    debug = (string, color="black", json=true) ->
      string = JSON.stringify string unless typeof string == "string"
      string = string.replace(/,/g, ', ').replace(/":/g, '": ') if json
      paragraph = $("<p>\#{string}<\p>")
      paragraph.appendTo("#debug")
      paragraph.css("color", color)
      $("#debug").scrollTo(paragraph) unless window.stop_scroll_debug?
    window.debug = debug

    # set initial reconnection timeout to 2 seconds
    window.prev_reconnect_on = 1
    window.reconnect_on = 2
    @init_socket = ->
      # TODO: preinitialize #data with localStorage data
      # TODO: preinitialize #queue with localStorage queue
      Socket = if "MozWebSocket" of window then MozWebSocket else WebSocket
      # set time window for sending nacks
      window.nack_window = 10000
      # initialize local storage system variables
      localStorage._id = "#{session[:key]}"
      localStorage._index = JSON.stringify []
      localStorage._vector ?= JSON.stringify {}
      localStorage._send_queue ?= JSON.stringify []
      localStorage._reception_queue ?= JSON.stringify []
      localStorage._high_ends ?= JSON.stringify {}
      localStorage._nack_index ?= JSON.stringify {}
      localStorage._sender_index ?= JSON.stringify {}
      web_socket = new Socket("ws://localhost:8080/")
      window.web_socket = web_socket

      web_socket.onopen = ->
        # reset reconnection timeouts
        window.prev_reconnect_on = 1
        window.reconnect_on = 2
        $("#offbutton").html("Offline")
                       .removeClass("online")
                       .addClass("offline")
        # debug "connected..."
        window.web_socket.send JSON.stringify
          id: localStorage._id
          subscribe: true

      web_socket.onmessage = (evt) ->
        # debug evt.data, "Gainsboro"
        # fetch data from localstorage
        id = localStorage._id
        index = JSON.parse localStorage._index
        data = JSON.parse evt.data
        if data.index?                                    # set the initial index
          data.index[data.index.length] = id unless id in data.index
          index = data.index
          # save index updates to localstorage
          localStorage._index = JSON.stringify(index)
        else if data.subscribe? and data.id != id         # handle subscription
          index[index.length] = data.id
          # save index updates to localstorage
          localStorage._index = JSON.stringify(index)
        else if data.unsubscribe? and data.id != id       # handle unsubscription
          index.delete data.id
          # save index updates to localstorage
          localStorage._index = JSON.stringify(index)
        else if data.disable_clear?                       # disable clear data button
          $(".clear").addClass("disabled")
        else if data.clear?                               # clear all data in the local stora and reset system variables
          document.clear_data()
        else if data.arresto_momentum?
          document.interrupt()
        else if data.nack?                                # handle multicast nack
          debug evt.data
          document.send_retry data
        else if data.retry?                                # consume multicast retry
          # debug evt.data
          document.consume_retry data
        else if data.conflict?
          debug evt.data
        else if data.id != id                             # consume multicast messages
          document.store_data data
        # debug localStorage._index, "Gainsboro"

      web_socket.onclose = ->
        localStorage._index = JSON.stringify []
        $("#offbutton").html("Reconnect")
                       .removeClass("offline")
                       .addClass("online")
        # debug "socket closed"
        # debug localStorage._index, "Gainsboro"
        unless window.offline?
          debug "reconnecting in \#{window.reconnect_on} seconds...", "Gainsboro"
          setTimeout (->
            document.init_socket()
          ), window.reconnect_on * 1000
          # increase the timeout fibonacciwise in order to decrease the network load
          tmp = window.reconnect_on
          window.reconnect_on = window.reconnect_on + window.prev_reconnect_on
          window.prev_reconnect_on = tmp

    @store_data = (data) ->
      # set local variables
      {key, value, old_value} = data
      local_old_value = localStorage[key]
      local_old_value ?= "#ffffff"
      unless localStorage._id == data.id
        vector = JSON.parse localStorage._vector
        vector[id] ?= -1 for id of data.vector
        localStorage._vector = JSON.stringify vector
        # debug "\#{data.id} => \#{JSON.stringify data.vector} || \#{JSON.stringify vector}"
        # The message was already delivered
        if vector[data.id] >= data.vector[data.id]
          debug "Old message: \#{JSON.stringify data.vector}", "Crimson"
          return true # the data was skipped

        # There are messages missing
        if (missing_id = @missing_id_for data)?
          debug "Missing messages!", "Crimson"
          @enqueue data
          reception_queue = JSON.parse localStorage._reception_queue
          unless reception_queue.empty() or
                 (@missing_id_for reception_queue[0])?
            # the missing element is on the queue
            @consume_retry
              id: missing_id
              retry: []
          else # consider sending a nack
            high_ends = JSON.parse localStorage._high_ends
            document.handle_missing missing_id,                   # missing id
                                    vector[missing_id] + 1,       # start
                                    high_ends[missing_id],        # end
                                    data.id                       # data id
          return false # the data was qeued
        # The received data is corrupt
        if data.crc? and crc32("\#{data.key}|\#{data.value}") != data.crc
          debug "Checksum Error!", "Crimson"
          return true # TODO: handle this with a nack
        # update the vector
        vector[data.id] = data.vector[data.id]
        localStorage._vector = JSON.stringify vector

      # Visualize the data (to be) stored
      document.visualize_data_flow "\#{data.id}_\#{data.vector[data.id]}", # id
                                   "#data",                                # container
                                   key,                                    # column
                                   value,                                  # top_color
                                   old_value,                              # bottom_color
                                   old_value != local_old_value            # warning
      # conflict handling:
      # send conflict message to sender with minor id
      # sender broadcasts the fixed message
      if old_value != local_old_value
        # get the sender index
        sender_index = JSON.parse localStorage._sender_index
        previous = sender_index[key]
        # determine the winner of concurrent messages based on their unique id (cfr. Lamport's bakery algorithm)
        [loser, loser_vector, winner_vector] = if data.id > previous.id # new message is loser
          [data.id, data.vector, previous.vector]
        else # old message was loser
          # swap conflict indicators
          $("#\#{previous.id}_\#{previous.vector[previous.id]}").css("border", "1px solid red")
          $("#\#{data.id}_\#{data.vector[data.id]}").css("border", "none")
          # save the data
          document.save_data data
          [previous.id, previous.vector, data.vector]
        conflict =
          id: localStorage._id
          dest: loser
          vector: loser_vector
          old_vector: winner_vector
          object_id: key
          conflict: true
        debug "Sending conflict message to \#{loser} about \#{key}", "Crimson"
        window.web_socket.send JSON.stringify conflict
      else
        document.save_data data

      # color = "Gainsboro"
      # if local_old_value != old_value
      #   color = "Crimson"
      # debug "\#{key}: \#{old_value} -> \#{value}", color
      return true # the data was consumed

    @save_data = (data) ->
      # Actually store the data
      localStorage[data.key] = data.value
      # Store the sender for conflict resolution
      sender_index = JSON.parse localStorage._sender_index
      sender_index[data.key] = data
      localStorage._sender_index = JSON.stringify sender_index

    # Detect missing messages
    @missing_id_for = (data) ->
      vector = JSON.parse localStorage._vector
      high_ends = JSON.parse localStorage._high_ends
      missing_id = data.id if vector[data.id] + 1 < data.vector[data.id] and
                              (high_ends[data.id] >= data.vector[data.id] - 1 or
                               (high_ends[data.id] = data.vector[data.id] - 1)?)
      missing_ids = (id for id of data.vector when id != data.id and
                                                   vector[id] < data.vector[id] and
                                                   (high_ends[id] >= data.vector[id] or
                                                    (high_ends[id] = data.vector[id])?))
      missing_id ?= missing_ids[0]
      localStorage._high_ends = JSON.stringify high_ends
      missing_id

    @enqueue = (data) ->
      reception_queue = JSON.parse localStorage._reception_queue
      reception_queue.push data
      reception_queue.sort @by_vector
      localStorage._reception_queue = JSON.stringify reception_queue
      {key, value, old_value} = data
      document.visualize_data_flow "\#{data.id}_\#{data.vector[data.id]}", # id
                                   "#queue",                               # container
                                   key,                                    # column
                                   value,                                  # top_color
                                   old_value,                              # bottom_color
                                   false,                                  # warning
                                   true                                    # scroll

    # sort data by vector count for its id
    @by_vector_count = (first, last) ->
      first.vector[first.id] - last.vector[last.id]

    # sort data by time vector
    @by_vector = (first, last) ->
      do (first, last) ->
      first_keys = (count for count of first.vector).sort()
      last_keys = (count for count of last.vector).sort()
      first.vector[key] ?= -1 for key in last_keys
      last.vector[key] ?= -1 for key in first_keys
      bigger = []
      smaller = []
      for key in first_keys
        bigger.push key if first.vector[key] > last.vector[key]
        smaller.push key if first.vector[key] < last.vector[key]
      return 1 if bigger.length > 0 and smaller.empty()
      return -1 if bigger.empty() and smaller.length > 0
      return 0

    @handle_missing = (id, start, end, data_id) ->
      nack_index = JSON.parse localStorage._nack_index
      now = new Date().getTime()
      if not nack_index[id]? or                         # no nack sent yet
         nack_index[id].end < end or                    # previous nack doesn't include all messages
         now - nack_index[id].time > window.nack_window # nack timeout
        # only request the messages that are not requested yet
        start = nack_index[id].end + 1 if nack_index[id]? and
                                          now - nack_index[id].time <= window.nack_window
        nack_index[id] =
          applicant: data_id
          start: start
          end: end
          time: new Date().getTime()
        localStorage._nack_index = JSON.stringify nack_index
        nack =
          id: localStorage._id
          dest: id
          start: start
          end: end
          nack: true
        debug "Acquiring missing messages [\#{start}..\#{end}] for \#{id}", "CornflowerBlue"
        window.web_socket.send JSON.stringify nack

    @visualize_data_flow = (id, container, column, top_color, bottom_color, warning = false, scroll = false) ->
      $("<div id='\#{column}' class='color_column'>").appendTo("\#{container}") if $("\#{container} > #\#{column}").length == 0
      color_box = $("<div id='\#{id}' class='color_box' title='\#{id}'>")
      unless scroll
        color_box.prependTo("\#{container} > #\#{column}")
      else
        color_box.insertAfter("\#{container} > #\#{column} > .color_stub")
      color_box.css("border", "1px solid red") if warning
      color_box.css("background", "-webkit-gradient(linear, left top, left bottom, from(\#{top_color}), to(\#{bottom_color}))")
      $("\#{container} > #\#{column}").scrollTo(".color_box:last-child") if scroll

    @send_retry = (data) ->
      send_queue = JSON.parse localStorage._send_queue
      {start, end} = data
      $("#data #\#{localStorage._id}_\#{number}").css("border", "1px solid green") for number in [start..end]
      window.web_socket.send JSON.stringify
        id: localStorage._id
        dest: data.id
        retry: send_queue[start..end]

    @consume_retry = (data) ->
      # put retry on the queue
      for data_part in data.retry
        @enqueue data_part
      nack_index = JSON.parse localStorage._nack_index
      delete nack_index[data_id]
      localStorage._nack_index = JSON.stringify nack_index
      # process queued values
      data_id = data.id
      process_result = true
      # debug "Consuming queue", "CornflowerBlue"
      while process_result
        reception_queue = JSON.parse localStorage._reception_queue
        break if reception_queue.empty()
        data_part = reception_queue.shift()
        localStorage._reception_queue = JSON.stringify reception_queue
        process_result = @store_data data_part
        $("#queue #\#{data_part.id}_\#{data_part.vector[data_part.id]}").remove()
      reception_queue = JSON.parse localStorage._reception_queue
      if reception_queue.empty() and process_result
        debug "Resuming normal operation", "CornflowerBlue"

    @interrupt = ->
      window.interval_id ?= -1
      window.clearInterval window.interval_id
      delete window.interval_id
      $("#startbutton").html("Start")
                       .removeClass("stop")
                       .addClass("start")
      $("#speedbutton").html("Faster")
                       .hide()
      $(".clear").removeClass("disabled")
                 .show()

    @clear_data = ->
      for key of localStorage when key[0] != '_'
        localStorage.removeItem key
      localStorage._vector = JSON.stringify {}
      localStorage._send_queue = JSON.stringify []
      localStorage._reception_queue = JSON.stringify []
      localStorage._high_ends = JSON.stringify {}
      localStorage._nack_index = JSON.stringify {}
      localStorage._sender_index = JSON.stringify {}
      $("#queue > .color_column").html("<div class='color_stub'>")
      $("#data > .color_column").html("<div class='color_stub'>")
      $("#debug").html("")

    if Modernizr.localstorage and Modernizr.websockets
      document.init_socket()                              # initialize a web socket

#startbutton.button.start Start
#speedbutton.button.speed Faster
#clearbutton.button.clear Clear
#offbutton.button.offline Offline
#logbutton.button.log Hide Log
#arresto.button.arresto Arresto Momentum

%div.container
  #queue
    #key_01.color_column
      %div.color_stub
    #key_02.color_column
      %div.color_stub
    #key_03.color_column
      %div.color_stub
    #key_04.color_column
      %div.color_stub
    #key_05.color_column
      %div.color_stub
    #key_06.color_column
      %div.color_stub
    #key_07.color_column
      %div.color_stub
    #key_08.color_column
      %div.color_stub
    #key_09.color_column
      %div.color_stub
    #key_10.color_column
      %div.color_stub
    #key_11.color_column
      %div.color_stub
    #key_12.color_column
      %div.color_stub
    #key_13.color_column
      %div.color_stub
    #key_14.color_column
      %div.color_stub
    #key_15.color_column
      %div.color_stub
    #key_16.color_column
      %div.color_stub
    #key_17.color_column
      %div.color_stub
    #key_18.color_column
      %div.color_stub
    #key_19.color_column
      %div.color_stub
    #key_20.color_column
      %div.color_stub
%div.container
  #data
    #key_01.color_column
      %div.color_stub
    #key_02.color_column
      %div.color_stub
    #key_03.color_column
      %div.color_stub
    #key_04.color_column
      %div.color_stub
    #key_05.color_column
      %div.color_stub
    #key_06.color_column
      %div.color_stub
    #key_07.color_column
      %div.color_stub
    #key_08.color_column
      %div.color_stub
    #key_09.color_column
      %div.color_stub
    #key_10.color_column
      %div.color_stub
    #key_11.color_column
      %div.color_stub
    #key_12.color_column
      %div.color_stub
    #key_13.color_column
      %div.color_stub
    #key_14.color_column
      %div.color_stub
    #key_15.color_column
      %div.color_stub
    #key_16.color_column
      %div.color_stub
    #key_17.color_column
      %div.color_stub
    #key_18.color_column
      %div.color_stub
    #key_19.color_column
      %div.color_stub
    #key_20.color_column
      %div.color_stub
#debug
#footer
  #logo
    %a{:href => "http://www.w3.org/html/logo/"}<
      %img{:alt => "HTML5 Powered with Connectivity / Realtime, and Offline & Storage", :height => "64", :src => "http://www.w3.org/html/logo/badge/html5-badge-h-connectivity-storage.png", :title => "HTML5 Powered with Connectivity / Realtime, and Offline & Storage", :width => "165"}
  #id= "#{session[:key]}"
  #spacer

:coffeescript
  $ ->
    # semaphore to prevent doubleclick on buttons
    @acquire_semaphore = ->
      return false if window.semaphore
      window.semaphore = true
      setTimeout ->
        window.semaphore = false
      , 200

    # fetch data from localstorage
    id = localStorage._id
    index = JSON.parse localStorage._index
    @send_data = ->
      # increment vector timestamp for this process
      vector = JSON.parse localStorage._vector
      unless vector[localStorage._id]?
        count = vector[localStorage._id] = 0
      else
        count = ++vector[localStorage._id]
      localStorage._vector = JSON.stringify vector
      # generate data for localstorage
      number = (Math.floor(Math.random() * 20) + 1).toString()
      number = "0" + number until number.length == 2
      key = "key_" + number
      value = window.random_color()
      old_value = localStorage[key]
      old_value ?= "#ffffff"
      data =
        id: localStorage._id
        key: key
        value: value
        old_value: old_value
        crc: crc32("\#{key}|\#{value}")
        vector: vector
      # push the message in the sent queue for later reference
      send_queue = JSON.parse localStorage._send_queue
      send_queue[count] = data
      localStorage._send_queue = JSON.stringify send_queue
      # send and store the data
      window.web_socket.send JSON.stringify data
      document.store_data(data)

    @start = (interval) ->
      window.web_socket.send JSON.stringify
        id: id
        disable_clear: true
      window.interval_id = window.setInterval document.send_data, interval

    @stop = ->
      window.clearInterval window.interval_id
      delete window.interval_id

    if Modernizr.localstorage and Modernizr.websockets
      for elem in $(".button")
        do (elem) ->
          elem.onselectstart = ->
            false

      $("#startbutton").click ->
        if document.acquire_semaphore()
          unless window.interval_id?
            document.start 1000
            $(this).html("Stop")
                   .removeClass("start")
                   .addClass("stop")
            $(".clear").addClass("disabled")
                       .hide()
            $(".speed").show()
          else
            document.stop()
            $(this).html("Start")
                   .removeClass("stop")
                   .addClass("start")
            $(".speed").hide()
            $(".clear").removeClass("disabled")
                       .show()

      $("#speedbutton").click ->
        if document.acquire_semaphore()
          if $(this).html() == "Faster"
            document.stop()
            document.start(500)
            $(this).html("Aieee!!")
          else if $(this).html() == "Aieee!!"
            document.stop()
            document.start(50)
            $(this).html("Slower")
          else
            document.stop()
            document.start(1000)
            $(this).html("Faster")

      $("#clearbutton").click ->
        if document.acquire_semaphore()
          unless $(this).hasClass("disabled")
            window.web_socket.send JSON.stringify
              id: id
              clear: true

      $("#offbutton").click ->
        if document.acquire_semaphore()
          if $(this).html() == "Offline"
            window.offline = true
            window.web_socket.close()
          else
            delete window.offline
            document.init_socket()

      $("#logbutton").click ->
        if document.acquire_semaphore()
          if $(this).html() == "Show Log"
            $(this).html("Hide Log")
            $("#data").css("height", "20.5em")
            $("#debug").show()
          else
            $(this).html("Show Log")
            $("#debug").hide()
            $("#data").css("height", "38.15em")

      $("#arresto").click ->
        if document.acquire_semaphore()
          window.web_socket.send JSON.stringify
            id: id
            arresto_momentum: true

      $("#data").hover ->
        $(@).css("overflow-y", "auto")
      , ->
        $(@).css("overflow-y", "hidden")

      $("#debug").hover ->
        window.stop_scroll_debug = true
      , ->
        delete window.stop_scroll_debug


