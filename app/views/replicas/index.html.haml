
:coffeescript
  $ ->
    debug = (string, color="black", json=true) ->
      string = JSON.stringify string unless typeof string == "string"
      string = string.replace(/,/g, ', ').replace(/":/g, '": ') if json
      paragraph = $("<p>\#{string}<\p>")
      paragraph.appendTo("#debug")
      paragraph.css("color", color)
      $("#debug").scrollTo(paragraph, 50)
    window.debug = debug

    # set initial reconnection timeout to 2 seconds
    window.prev_reconnect_on = 1
    window.reconnect_on = 2
    @initSocket = ->
      # TODO: preinitialize #data with localStorage data
      # TODO: preinitialize #queue with localStorage queue
      Socket = if "MozWebSocket" of window then MozWebSocket else WebSocket
      # initialize local storage system variables
      localStorage._id = "#{session[:key]}"
      localStorage._index = JSON.stringify []
      localStorage._vector ?= JSON.stringify {}
      localStorage._send_queue ?= JSON.stringify []
      localStorage._delivery_queue ?= JSON.stringify {}
      localStorage._nack_index ?= JSON.stringify {}
      web_socket = new Socket("ws://localhost:8080/")
      window.web_socket = web_socket

      web_socket.onopen = ->
        # reset reconnection timeouts
        window.prev_reconnect_on = 1
        window.reconnect_on = 2
        $("#offbutton").html("Offline")
                       .removeClass("online")
                       .addClass("offline")
        # debug "connected..."
        window.web_socket.send JSON.stringify
          id: localStorage._id
          subscribe: true

      web_socket.onmessage = (evt) ->
        # debug evt.data, "Gainsboro"
        # fetch data from localstorage
        id = localStorage._id
        index = JSON.parse localStorage._index
        data = JSON.parse evt.data
        if data.index?                                    # set the initial index
          data.index[data.index.length] = id unless id in data.index
          index = data.index
          # save index updates to localstorage
          localStorage._index = JSON.stringify(index)
        else if data.subscribe? and data.id != id         # handle subscription
          index[index.length] = data.id
          # save index updates to localstorage
          localStorage._index = JSON.stringify(index)
        else if data.unsubscribe? and data.id != id       # handle unsubscription
          index.delete data.id
          # save index updates to localstorage
          localStorage._index = JSON.stringify(index)
        else if data.disable_clear?                       # disable clear data button
          $(".clear").addClass("disabled")
        else if data.clear?                               # clear all data in the local stora and reset system variables
          document.clear_data()
        else if data.arresto_momentum?
          document.stop()
        else if data.nack?                                # handle multicast nack
          debug evt.data
          document.send_rack data
        else if data.rack?                                # consume multicast rack
          debug evt.data
          document.consume_rack data
        else if data.id != id                             # consume multicast messages
          document.store_data data
        # debug localStorage._index, "Gainsboro"

      web_socket.onclose = ->
        localStorage._index = JSON.stringify []
        $("#offbutton").html("Reconnect")
                       .removeClass("offline")
                       .addClass("online")
        # debug "socket closed"
        # debug localStorage._index, "Gainsboro"
        unless window.offline?
          debug "reconnecting in \#{window.reconnect_on} seconds...", "Gainsboro"
          setTimeout (->
            document.initSocket()
          ), window.reconnect_on * 1000
          # increase the timeout fibonacciwise in order to decrease the network load
          tmp = window.reconnect_on
          window.reconnect_on = window.reconnect_on + window.prev_reconnect_on
          window.prev_reconnect_on = tmp

    @store_data = (data) ->
      # set local variables
      {key, value, old_value} = data
      local_old_value = localStorage[key]
      local_old_value ?= "#ffffff"
      unless localStorage._id == data.id
        vector = JSON.parse localStorage._vector
        vector[id] ?= -1 for id of data.vector
        debug "\#{JSON.stringify data.vector} || \#{JSON.stringify vector}"
        # The message was already delivered
        if vector[data.id] >= data.vector[data.id]
          debug "Old message", "Crimson"
          return true # the data was skipped
        # Detect missing messages
        missing = (id for id of data.vector when (id != data.id and vector[id] < data.vector[id]) or vector[id] + 1 < data.vector[id])
        # There are messages missing
        unless missing.empty()
          debug "Missing messages!", "Crimson"
          delivery_queue = JSON.parse localStorage._delivery_queue
          delivery_queue[data.id] ?= []
          # debug missing
          missing_result = []
          for missing_id in missing
            delivery_queue[missing_id] ?= []
            queue = (queued = delivery_queue[missing_id][0])? and 
                    queued.vector[missing_id] == vector[missing_id] + 1 # should the queue be consumed?
            end = if missing_id == data.id then data.vector[missing_id] - 1 else data.vector[missing_id]
            missing_result.push document.handle_missing missing_id,
                                                        vector[missing_id] + 1,
                                                        end,
                                                        data.id,
                                                        queue
          if true in missing_result # at least one nack was sent or no matching element was found in the queue
            delivery_queue[data.id].push data
            localStorage._delivery_queue = JSON.stringify delivery_queue
            document.visualize_data_flow("\#{data.id}_\#{data.vector[data.id]}", "#queue", key, value, old_value, false, true)
            return false # the data was qeued
        # The received data is corrupt
        if data.crc? and crc32("\#{data.key}|\#{data.value}") != data.crc
          debug "Checksum Error!", "Crimson"
          return true # TODO: handle this with a nack
        # update the vector
        vector[data.id] = data.vector[data.id]
        localStorage._vector = JSON.stringify vector

      # Actually store the data
      localStorage[key] = value
      # Visualize the data stored
      document.visualize_data_flow("\#{data.id}_\#{data.vector[data.id]}", "#data", key, value, old_value, old_value != local_old_value)
      # color = "Gainsboro"
      # if local_old_value != old_value
      #   color = "Crimson"
      # debug "\#{key}: \#{old_value} -> \#{value}", color
      return true # the data was consumed

    @handle_missing = (id, start, end, data_id, queue) ->      
      nack_index = JSON.parse localStorage._nack_index
      unless nack_index[id]?
        nack_index[id] = data_id
        localStorage._nack_index = JSON.stringify nack_index
        nack =
          id: localStorage._id
          dest: id
          start: start
          end: end
          nack: true
        debug "Acquiring missing messages for \#{id}", "CornflowerBlue"
        window.web_socket.send JSON.stringify nack
        return true
      else if queue
        debug "Hey, I'm dequeueing! How come?"
        @consume_rack
          id: id
          rack: []
        return false
      return true

    @visualize_data_flow = (id, container, column, top_color, bottom_color, warning = false, scroll = false) ->
      $("<div id='\#{column}' class='color_column'>").appendTo("\#{container}") if $("\#{container} > #\#{column}").length == 0
      color_box = $("<div id='\#{id}' class='color_box'>")
      unless scroll
        color_box.prependTo("\#{container} > #\#{column}")
      else
        color_box.insertAfter("\#{container} > #\#{column} > .color_stub")
      color_box.css("border", "1px solid red") if warning
      color_box.css("background", "-webkit-gradient(linear, left top, left bottom, from(\#{top_color}), to(\#{bottom_color}))")
      $("\#{container} > #\#{column}").scrollTo(".color_box:last-child") if scroll

    @send_rack = (data) ->
      send_queue = JSON.parse localStorage._send_queue
      {start, end} = data
      $("#data #\#{localStorage._id}_\#{number}").css("border", "1px solid green") for number in [start..end]
      window.web_socket.send JSON.stringify
        id: localStorage._id
        dest: data.id
        rack: send_queue[start..end]

    @consume_rack = (data) ->
      # consume rack
      nack_result = (@store_data data_part for data_part in data.rack)   
      unless false in nack_result
        # process queued values  
        queue_result = [] 
        data_id = data.id
        delivery_queue = JSON.parse localStorage._delivery_queue
        nack_index = JSON.parse localStorage._nack_index
        until false in queue_result
          queued = delivery_queue[data_id]
          queued ?= []
          delete delivery_queue[data_id]
          localStorage._delivery_queue = JSON.stringify delivery_queue
          debug "Consuming queue for \#{data_id}", "CornflowerBlue"
          queue_result = for data_part in queued
            # debug data_part
            $("#queue #\#{data_part.id}_\#{data_part.vector[data_part.id]}").remove()
            @store_data data_part
          new_data_id = nack_index[data_id]
          # reset nack index
          delete nack_index[data_id] unless false in queue_result
          break if new_data_id == data_id # all queues processed
          data_id = new_data_id
      localStorage._nack_index = JSON.stringify nack_index
      unless false in nack_result or false in queue_result
        debug "Resuming normal operation", "CornflowerBlue"    
    
    @stop = ->
      window.interval_id ?= -1
      window.clearInterval window.interval_id
      delete window.interval_id
      $("#startbutton").html("Start")
                         .removeClass("stop")
                         .addClass("start")
      $(".clear").removeClass("disabled")

    @clear_data = ->
      for key of localStorage when key[0] != '_'
        localStorage.removeItem key
      localStorage._vector = JSON.stringify {}
      localStorage._send_queue = JSON.stringify []
      localStorage._delivery_queue = JSON.stringify {}
      localStorage._nack_index = JSON.stringify {}
      $("#queue > .color_column").html("<div class='color_stub'>")
      $("#data > .color_column").html("<div class='color_stub'>")
      $("#debug").html("")

    if Modernizr.localstorage and Modernizr.websockets
      document.initSocket()                              # initialize a web socket

#startbutton.button.start Start
#clearbutton.button.clear Clear
#offbutton.button.offline Offline
#logbutton.button.log Hide Log
#arresto.button.arresto Arresto Momentum
-# TODO add speed dial

%div.container
  #queue
    #key_01.color_column
      %div.color_stub
    #key_02.color_column
      %div.color_stub
    #key_03.color_column
      %div.color_stub
    #key_04.color_column
      %div.color_stub
    #key_05.color_column
      %div.color_stub
    #key_06.color_column
      %div.color_stub
    #key_07.color_column
      %div.color_stub
    #key_08.color_column
      %div.color_stub
    #key_09.color_column
      %div.color_stub
    #key_10.color_column
      %div.color_stub
    #key_11.color_column
      %div.color_stub
    #key_12.color_column
      %div.color_stub
    #key_13.color_column
      %div.color_stub
    #key_14.color_column
      %div.color_stub
    #key_15.color_column
      %div.color_stub
    #key_16.color_column
      %div.color_stub
    #key_17.color_column
      %div.color_stub
    #key_18.color_column
      %div.color_stub
    #key_19.color_column
      %div.color_stub
    #key_20.color_column
      %div.color_stub
%div.container
  #data
    #key_01.color_column
      %div.color_stub
    #key_02.color_column
      %div.color_stub
    #key_03.color_column
      %div.color_stub
    #key_04.color_column
      %div.color_stub
    #key_05.color_column
      %div.color_stub
    #key_06.color_column
      %div.color_stub
    #key_07.color_column
      %div.color_stub
    #key_08.color_column
      %div.color_stub
    #key_09.color_column
      %div.color_stub
    #key_10.color_column
      %div.color_stub
    #key_11.color_column
      %div.color_stub
    #key_12.color_column
      %div.color_stub
    #key_13.color_column
      %div.color_stub
    #key_14.color_column
      %div.color_stub
    #key_15.color_column
      %div.color_stub
    #key_16.color_column
      %div.color_stub
    #key_17.color_column
      %div.color_stub
    #key_18.color_column
      %div.color_stub
    #key_19.color_column
      %div.color_stub
    #key_20.color_column
      %div.color_stub
#debug
#id= "#{session[:key]}"

:coffeescript
  $ ->
    # semaphore to prevent doubleclick on buttons
    @acquire_semaphore = ->
      return false if window.semaphore
      window.semaphore = true
      setTimeout ->
        window.semaphore = false
      , 500
    
    # fetch data from localstorage
    id = localStorage._id
    index = JSON.parse localStorage._index
    @send_data = ->
      # increment vector timestamp for this process
      vector = JSON.parse localStorage._vector
      unless vector[localStorage._id]?
        count = vector[localStorage._id] = 0
      else
        count = ++vector[localStorage._id]
      localStorage._vector = JSON.stringify vector
      # generate data for localstorage
      number = (Math.floor(Math.random() * 20) + 1).toString()
      number = "0" + number until number.length == 2
      key = "key_" + number
      value = window.random_color()
      old_value = localStorage[key]
      old_value ?= "#ffffff"
      data =
        id: localStorage._id
        key: key
        value: value
        old_value: old_value
        crc: crc32("\#{key}|\#{value}")
        vector: vector
      # push the message in the sent queue for later reference
      send_queue = JSON.parse localStorage._send_queue
      send_queue[count] = data
      localStorage._send_queue = JSON.stringify send_queue
      # send and store the data
      window.web_socket.send JSON.stringify data
      document.store_data(data)

    if Modernizr.localstorage and Modernizr.websockets
      # TODO disable doubleclick
      # TODO disable log scrolling on mouseover
      # TODO show log scrollbar on mouseover
      for elem in $(".button")
        do (elem) ->
          elem.onselectstart = ->
            false
      $("#startbutton").click ->
        if document.acquire_semaphore()
          unless window.interval_id?
            window.web_socket.send JSON.stringify
              id: id
              disable_clear: true
            window.interval_id = window.setInterval document.send_data, 1000
            $(this).html("Stop")
                   .removeClass("start")
                   .addClass("stop")
            $(".clear").addClass("disabled")
          else
            window.clearInterval window.interval_id
            delete window.interval_id
            $(this).html("Start")
                   .removeClass("stop")
                   .addClass("start")
            $(".clear").removeClass("disabled")

      $("#clearbutton").click ->
        if document.acquire_semaphore()
          unless $(this).hasClass("disabled")
            window.web_socket.send JSON.stringify
              id: id
              clear: true

      $("#offbutton").click ->
        if document.acquire_semaphore()
          if $(this).html() == "Offline"
            window.offline = true
            window.web_socket.close()
          else
            delete window.offline
            document.initSocket()

      $("#logbutton").click ->
        if document.acquire_semaphore()
          if $(this).html() == "Show Log"
            $(this).html("Hide Log")
            $("#data").css("height", "24em")
            $("#debug").show()
          else
            $(this).html("Show Log")
            $("#debug").hide()
            $("#data").css("height", "41.65em")
      
      $("#arresto").click ->
        if document.acquire_semaphore()
          window.web_socket.send JSON.stringify
            id: id
            arresto_momentum: true
        