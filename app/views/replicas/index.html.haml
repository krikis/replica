
:coffeescript
  $ ->
    debug = (string, color="black", json=true) ->
      string = JSON.stringify string unless typeof string == "string"
      string = string.replace(/,/g, ', ').replace(/":/g, '": ') if json
      paragraph = $("<p>\#{string}<\p>")
      paragraph.appendTo("#debug")
      paragraph.css("color", color)
      $("#debug").scrollTo(paragraph) unless window.stop_scroll_debug?
    window.debug = debug

    # set initial reconnection timeout to 2 seconds
    window.prev_reconnect_on = 1
    window.reconnect_on = 2
    @initSocket = ->
      # TODO: preinitialize #data with localStorage data
      # TODO: preinitialize #queue with localStorage queue
      Socket = if "MozWebSocket" of window then MozWebSocket else WebSocket
      # set time window for sending nacks
      window.nack_window = 10000
      # initialize local storage system variables
      localStorage._id = "#{session[:key]}"
      localStorage._index = JSON.stringify []
      localStorage._vector ?= JSON.stringify {}
      localStorage._send_queue ?= JSON.stringify []
      localStorage._delivery_queue ?= JSON.stringify {}
      localStorage._receive_queue ?= JSON.stringify []
      localStorage._high_ends ?= JSON.stringify {}
      localStorage._nack_index ?= JSON.stringify {}
      web_socket = new Socket("ws://localhost:8080/")
      window.web_socket = web_socket

      web_socket.onopen = ->
        # reset reconnection timeouts
        window.prev_reconnect_on = 1
        window.reconnect_on = 2
        $("#offbutton").html("Offline")
                       .removeClass("online")
                       .addClass("offline")
        # debug "connected..."
        window.web_socket.send JSON.stringify
          id: localStorage._id
          subscribe: true

      web_socket.onmessage = (evt) ->
        # debug evt.data, "Gainsboro"
        # fetch data from localstorage
        id = localStorage._id
        index = JSON.parse localStorage._index
        data = JSON.parse evt.data
        if data.index?                                    # set the initial index
          data.index[data.index.length] = id unless id in data.index
          index = data.index
          # save index updates to localstorage
          localStorage._index = JSON.stringify(index)
        else if data.subscribe? and data.id != id         # handle subscription
          index[index.length] = data.id
          # save index updates to localstorage
          localStorage._index = JSON.stringify(index)
        else if data.unsubscribe? and data.id != id       # handle unsubscription
          index.delete data.id
          # save index updates to localstorage
          localStorage._index = JSON.stringify(index)
        else if data.disable_clear?                       # disable clear data button
          $(".clear").addClass("disabled")
        else if data.clear?                               # clear all data in the local stora and reset system variables
          document.clear_data()
        else if data.arresto_momentum?
          document.stop()
        else if data.nack?                                # handle multicast nack
          debug evt.data
          document.send_rack data
        else if data.rack?                                # consume multicast rack
          # debug evt.data
          document.consume_rack data
        else if data.id != id                             # consume multicast messages
          document.store_data data
        # debug localStorage._index, "Gainsboro"

      web_socket.onclose = ->
        localStorage._index = JSON.stringify []
        $("#offbutton").html("Reconnect")
                       .removeClass("offline")
                       .addClass("online")
        # debug "socket closed"
        # debug localStorage._index, "Gainsboro"
        unless window.offline?
          debug "reconnecting in \#{window.reconnect_on} seconds...", "Gainsboro"
          setTimeout (->
            document.initSocket()
          ), window.reconnect_on * 1000
          # increase the timeout fibonacciwise in order to decrease the network load
          tmp = window.reconnect_on
          window.reconnect_on = window.reconnect_on + window.prev_reconnect_on
          window.prev_reconnect_on = tmp

    @store_data = (data) ->
      # set local variables
      {key, value, old_value} = data
      local_old_value = localStorage[key]
      local_old_value ?= "#ffffff"
      unless localStorage._id == data.id
        vector = JSON.parse localStorage._vector
        vector[id] ?= -1 for id of data.vector
        debug "\#{data.id} => \#{JSON.stringify data.vector} || \#{JSON.stringify vector}"
        # The message was already delivered
        if vector[data.id] >= data.vector[data.id]
          debug "Old message", "Crimson"
          return true # the data was skipped
        # Detect missing messages
        high_ends = JSON.parse localStorage._high_ends
        missing_id = data.id if vector[data.id] + 1 < data.vector[data.id] and
                                (high_ends[data.id] >= data.vector[data.id] - 1 or
                                 high_ends[data.id] = data.vector[data.id] - 1)
        missing_ids = (id for id of data.vector when id != data.id and
                                                     vector[id] < data.vector[id] and
                                                     (high_ends[id] >= data.vector[id] or
                                                      high_ends[id] = data.vector[id]))
        missing_id ?= missing_ids[0]
        localStorage._high_ends = JSON.stringify high_ends
        # There are messages missing
        if missing_id?
          debug "Missing messages!", "Crimson"
          @enqueue data
          delivery_queue = JSON.parse localStorage._delivery_queue
          delivery_queue[missing_id] ?= []
          if (queued = delivery_queue[missing_id][0])? and
              queued.vector[missing_id] == vector[missing_id] + 1 # the missing element in on the queue
            @consume_rack
              id: missing_id
              rack: []
          else # consider sending a nack
            document.handle_missing missing_id,                   # missing id
                                    vector[missing_id] + 1,       # start
                                    high_ends[missing_id],        # end
                                    data.id                       # data id
          return false # the data was qeued
        # The received data is corrupt
        if data.crc? and crc32("\#{data.key}|\#{data.value}") != data.crc
          debug "Checksum Error!", "Crimson"
          return true # TODO: handle this with a nack
        # update the vector
        vector[data.id] = data.vector[data.id]
        localStorage._vector = JSON.stringify vector

      # Actually store the data
      localStorage[key] = value
      # Visualize the data stored
      document.visualize_data_flow "\#{data.id}_\#{data.vector[data.id]}", # id
                                   "#data",                                # container
                                   key,                                    # column
                                   value,                                  # top_color
                                   old_value,                              # bottom_color
                                   old_value != local_old_value            # warning
      # color = "Gainsboro"
      # if local_old_value != old_value
      #   color = "Crimson"
      # debug "\#{key}: \#{old_value} -> \#{value}", color
      return true # the data was consumed

    @enqueue = (data) ->
      delivery_queue = JSON.parse localStorage._delivery_queue
      delivery_queue[data.id] ?= []
      delivery_queue[data.id].push data
      delivery_queue[data.id].sort @by_vector_count
      localStorage._delivery_queue = JSON.stringify delivery_queue
      {key, value, old_value} = data
      document.visualize_data_flow "\#{data.id}_\#{data.vector[data.id]}", # id
                                   "#queue",                               # container
                                   key,                                    # column
                                   value,                                  # top_color
                                   old_value,                              # bottom_color
                                   false,                                  # warning
                                   true                                    # scroll

    # sort data by vector count for its id
    @by_vector_count = (first, last) ->
      first.vector[first.id] - last.vector[last.id]
      
    @by_vector = (first, last) ->
      first_keys = (count for count of first.vector).sort()
      last_keys = (count for count of first.vector).sort()
      last.vector[key] ?= -1 for key in first_keys
      first.vector[key] ?= -1 for key in last_keys
      bigger = smaller = []
      for key in first_keys
        bigger.push key if first.vector[key] > last.vector[key]
        smaller.push key if first.vector[key] < last.vector[key]
      return -1 if bigger.length > 0 and smaller.empty()
      return 1 if bigger.empty() and smaller.length > 0
      return 0

    @handle_missing = (id, start, end, data_id) ->
      nack_index = JSON.parse localStorage._nack_index
      now = new Date().getTime()
      if not nack_index[id]? or                         # no nack sent yet
         nack_index[id].end < end or                    # previous nack doesn't include all messages
         now - nack_index[id].time > window.nack_window # nack timeout
        # only request the messages that are not requested yet
        start = nack_index[id].end + 1 if nack_index[id]? and
                                          now - nack_index[id].time <= window.nack_window
        nack_index[id] =
          applicant: data_id
          start: start
          end: end
          time: new Date().getTime()
        localStorage._nack_index = JSON.stringify nack_index
        nack =
          id: localStorage._id
          dest: id
          start: start
          end: end
          nack: true
        debug "Acquiring missing messages for \#{id}", "CornflowerBlue"
        window.web_socket.send JSON.stringify nack

    @visualize_data_flow = (id, container, column, top_color, bottom_color, warning = false, scroll = false) ->
      $("<div id='\#{column}' class='color_column'>").appendTo("\#{container}") if $("\#{container} > #\#{column}").length == 0
      color_box = $("<div id='\#{id}' class='color_box' title='\#{id}'>")
      unless scroll
        color_box.prependTo("\#{container} > #\#{column}")
      else
        color_box.insertAfter("\#{container} > #\#{column} > .color_stub")
      color_box.css("border", "1px solid red") if warning
      color_box.css("background", "-webkit-gradient(linear, left top, left bottom, from(\#{top_color}), to(\#{bottom_color}))")
      $("\#{container} > #\#{column}").scrollTo(".color_box:last-child") if scroll

    @send_rack = (data) ->
      send_queue = JSON.parse localStorage._send_queue
      {start, end} = data
      $("#data #\#{localStorage._id}_\#{number}").css("border", "1px solid green") for number in [start..end]
      window.web_socket.send JSON.stringify
        id: localStorage._id
        dest: data.id
        rack: send_queue[start..end]

    @consume_rack = (data) ->
      # put rack on the queue
      for data_part in data.rack
        @enqueue data_part
      # process queued values
      data_id = data.id
      process_result = true
      loop
        debug "Consuming queue for \#{data_id}", "CornflowerBlue"
        while process_result
          delivery_queue = JSON.parse localStorage._delivery_queue
          queued = delivery_queue[data_id]
          queued ?= []
          break if queued.empty()
          data_part = queued.shift()
          localStorage._delivery_queue = JSON.stringify delivery_queue
          process_result = @store_data data_part
          $("#queue #\#{data_part.id}_\#{data_part.vector[data_part.id]}").remove()
        delivery_queue = JSON.parse localStorage._delivery_queue
        queued = delivery_queue[data_id]
        queued ?= []
        break unless queued.empty()
        nack_index = JSON.parse localStorage._nack_index
        break unless nack_index[data_id]?
        new_data_id = nack_index[data_id].applicant
        delete nack_index[data_id]
        localStorage._nack_index = JSON.stringify nack_index
        break if new_data_id == data_id
        data_id = new_data_id
      delivery_queue = JSON.parse localStorage._delivery_queue
      queued = delivery_queue[data_id]
      queued ?= []
      if queued.empty() and process_result
        debug "Resuming normal operation", "CornflowerBlue"

    @stop = ->
      window.interval_id ?= -1
      window.clearInterval window.interval_id
      delete window.interval_id
      $("#startbutton").html("Start")
                         .removeClass("stop")
                         .addClass("start")
      $(".clear").removeClass("disabled")

    @clear_data = ->
      for key of localStorage when key[0] != '_'
        localStorage.removeItem key
      localStorage._vector = JSON.stringify {}
      localStorage._send_queue = JSON.stringify []
      localStorage._delivery_queue = JSON.stringify {}
      localStorage._receive_queue = JSON.stringify []
      localStorage._high_ends = JSON.stringify {}
      localStorage._nack_index = JSON.stringify {}
      $("#queue > .color_column").html("<div class='color_stub'>")
      $("#data > .color_column").html("<div class='color_stub'>")
      $("#debug").html("")

    if Modernizr.localstorage and Modernizr.websockets
      document.initSocket()                              # initialize a web socket

#startbutton.button.start Start
#clearbutton.button.clear Clear
#offbutton.button.offline Offline
#logbutton.button.log Hide Log
#arresto.button.arresto Arresto Momentum
-# TODO add speed dial

%div.container
  #queue
    #key_01.color_column
      %div.color_stub
    #key_02.color_column
      %div.color_stub
    #key_03.color_column
      %div.color_stub
    #key_04.color_column
      %div.color_stub
    #key_05.color_column
      %div.color_stub
    #key_06.color_column
      %div.color_stub
    #key_07.color_column
      %div.color_stub
    #key_08.color_column
      %div.color_stub
    #key_09.color_column
      %div.color_stub
    #key_10.color_column
      %div.color_stub
    #key_11.color_column
      %div.color_stub
    #key_12.color_column
      %div.color_stub
    #key_13.color_column
      %div.color_stub
    #key_14.color_column
      %div.color_stub
    #key_15.color_column
      %div.color_stub
    #key_16.color_column
      %div.color_stub
    #key_17.color_column
      %div.color_stub
    #key_18.color_column
      %div.color_stub
    #key_19.color_column
      %div.color_stub
    #key_20.color_column
      %div.color_stub
%div.container
  #data
    #key_01.color_column
      %div.color_stub
    #key_02.color_column
      %div.color_stub
    #key_03.color_column
      %div.color_stub
    #key_04.color_column
      %div.color_stub
    #key_05.color_column
      %div.color_stub
    #key_06.color_column
      %div.color_stub
    #key_07.color_column
      %div.color_stub
    #key_08.color_column
      %div.color_stub
    #key_09.color_column
      %div.color_stub
    #key_10.color_column
      %div.color_stub
    #key_11.color_column
      %div.color_stub
    #key_12.color_column
      %div.color_stub
    #key_13.color_column
      %div.color_stub
    #key_14.color_column
      %div.color_stub
    #key_15.color_column
      %div.color_stub
    #key_16.color_column
      %div.color_stub
    #key_17.color_column
      %div.color_stub
    #key_18.color_column
      %div.color_stub
    #key_19.color_column
      %div.color_stub
    #key_20.color_column
      %div.color_stub
#debug
#id= "#{session[:key]}"

:coffeescript
  $ ->
    # semaphore to prevent doubleclick on buttons
    @acquire_semaphore = ->
      return false if window.semaphore
      window.semaphore = true
      setTimeout ->
        window.semaphore = false
      , 500

    # fetch data from localstorage
    id = localStorage._id
    index = JSON.parse localStorage._index
    @send_data = ->
      # increment vector timestamp for this process
      vector = JSON.parse localStorage._vector
      unless vector[localStorage._id]?
        count = vector[localStorage._id] = 0
      else
        count = ++vector[localStorage._id]
      localStorage._vector = JSON.stringify vector
      # generate data for localstorage
      number = (Math.floor(Math.random() * 20) + 1).toString()
      number = "0" + number until number.length == 2
      key = "key_" + number
      value = window.random_color()
      old_value = localStorage[key]
      old_value ?= "#ffffff"
      data =
        id: localStorage._id
        key: key
        value: value
        old_value: old_value
        crc: crc32("\#{key}|\#{value}")
        vector: vector
      # push the message in the sent queue for later reference
      send_queue = JSON.parse localStorage._send_queue
      send_queue[count] = data
      localStorage._send_queue = JSON.stringify send_queue
      # send and store the data
      window.web_socket.send JSON.stringify data
      document.store_data(data)

    if Modernizr.localstorage and Modernizr.websockets
      # TODO disable doubleclick
      # TODO disable log scrolling on mouseover
      # TODO show log scrollbar on mouseover
      for elem in $(".button")
        do (elem) ->
          elem.onselectstart = ->
            false
      $("#startbutton").click ->
        if document.acquire_semaphore()
          unless window.interval_id?
            window.web_socket.send JSON.stringify
              id: id
              disable_clear: true
            window.interval_id = window.setInterval document.send_data, 1000
            $(this).html("Stop")
                   .removeClass("start")
                   .addClass("stop")
            $(".clear").addClass("disabled")
          else
            window.clearInterval window.interval_id
            delete window.interval_id
            $(this).html("Start")
                   .removeClass("stop")
                   .addClass("start")
            $(".clear").removeClass("disabled")

      $("#clearbutton").click ->
        if document.acquire_semaphore()
          unless $(this).hasClass("disabled")
            window.web_socket.send JSON.stringify
              id: id
              clear: true

      $("#offbutton").click ->
        if document.acquire_semaphore()
          if $(this).html() == "Offline"
            window.offline = true
            window.web_socket.close()
          else
            delete window.offline
            document.initSocket()

      $("#logbutton").click ->
        if document.acquire_semaphore()
          if $(this).html() == "Show Log"
            $(this).html("Hide Log")
            $("#data").css("height", "24em")
            $("#debug").show()
          else
            $(this).html("Show Log")
            $("#debug").hide()
            $("#data").css("height", "41.65em")

      $("#arresto").click ->
        if document.acquire_semaphore()
          window.web_socket.send JSON.stringify
            id: id
            arresto_momentum: true

      $("#data").hover ->
        $(@).css("overflow-y", "auto")
      , ->
        $(@).css("overflow-y", "hidden")

      $("#debug").hover ->
        window.stop_scroll_debug = true
      , ->
        delete window.stop_scroll_debug


